<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>BEAM</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,700&display=swap" rel="stylesheet" />
  
  <!-- Firebase Dependencies -->
  <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.6.8/firebase-database.js"></script>
  
  <style>
    :root {
      --purple: rgb(188, 185, 224);
      --target-purple: rgb(128, 88, 243);
      --dark-grey: rgb(54, 54, 54);
      --light-grey-text: rgb(200, 200, 200);
      --white: rgb(255, 255, 255);
      --black: rgb(0, 0, 0);
      --shadow-light: 0 4px 15px rgba(0, 0, 0, 0.2);
      --shadow-heavy: 0 6px 20px rgba(0, 0, 0, 0.3);
      --frame-radius: 35px;
      --canvas-radius: 25px;
      --score-text: #363636;
      --gutter: 15px;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; font-family: 'Playfair Display', serif; font-weight: 700; font-style: italic; }
    html, body { width: 100%; height: 100%; background-color: #222; color: var(--white); overflow: hidden; display: flex; justify-content: center; align-items: center; }
    #game-container { display: flex; flex-direction: column; width: 100%; height: auto; max-width: 2000px; max-height: 1200px; box-shadow: var(--shadow-heavy); border-radius: var(--frame-radius); overflow: hidden; background: var(--dark-grey); position: relative; }
    @media (min-aspect-ratio: 1/2) { #game-container { width: auto; height: 100%; } }
    #hud { display: flex; justify-content: space-between; align-items: center; background-color: var(--dark-grey); padding: 14px 18px; flex-shrink: 0; position: relative; z-index: 5; min-height: 80px; border-bottom-left-radius: 0; border-bottom-right-radius: 0; }
    .hud-plaque { background-color: #2a2a2a; padding: 8px 16px; border-radius: 12px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 1px 1px rgba(255,255,255,0.1); color: var(--light-grey-text); font-size: 1em; text-align: center; }
    #timer-display { position: absolute; left: 50%; top: 14px; transform: translateX(-50%); width: 80px; height: 80px; border-radius: 50%; background: var(--dark-grey); border: 5px solid var(--white); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; box-shadow: var(--shadow-heavy); }
    #timer-value { font-size: 2.2em; line-height: 1; }
    #score-display { font-size: 1.1em; color: var(--purple); margin-top: 2px; }
    #canvas-wrapper { flex-grow: 1; position: relative; background-color: var(--purple); padding-left: var(--gutter); padding-right: var(--gutter); padding-bottom: var(--gutter); margin-top: -50px; padding-top: calc(44px + var(--gutter)); display: flex; align-items: center; justify-content: center; }
    canvas { display: block; width: 100%; height: auto; aspect-ratio: 1 / 1; background-color: var(--white); border-radius: var(--canvas-radius); border: 6px solid var(--black); box-shadow: inset 0 0 20px rgba(0,0,0,0.5); }
    #controls { position: relative; flex-shrink: 0; display: flex; justify-content: center; align-items: center; padding: 14px 18px 18px; min-height: 110px; background: var(--dark-grey); border-top: 2px solid var(--black); border-top-left-radius: 0; border-top-right-radius: 0; }
    #pause-btn { position: absolute; left: 50%; top: 14px; transform: translateX(-50%); width: 80px; height: 80px; border-radius: 50%; background-color: var(--dark-grey); border: 5px solid var(--white); cursor: pointer; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; box-shadow: var(--shadow-heavy); }
    #pause-btn:hover { transform: translateX(-50%) scale(1.06); }
    #pause-btn svg { width: 22px; height: 22px; fill: var(--purple); }
    button:focus { outline: none; }
    button:focus-visible { box-shadow: 0 0 0 3px var(--target-purple); }
    .overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; z-index: 20; pointer-events: none; }
    .overlay.active { opacity: 1; visibility: visible; }
    .overlay-content { color: var(--white); pointer-events: auto; }
    .overlay-content h1 { font-size: 2.8em; }
    .overlay-content h2 { font-size: 4em; }
    .overlay-content p  { font-size: 1.5em; }
    @keyframes glowing-text { 0%   { text-shadow: 0 0 5px var(--white), 0 0 10px var(--white), 0 0 15px var(--purple); } 50%  { text-shadow: 0 0 10px var(--white), 0 0 20px var(--purple), 0 0 30px var(--purple); } 100% { text-shadow: 0 0 5px var(--white), 0 0 10px var(--white), 0 0 15px var(--purple); } }
    .animated-glow { animation: glowing-text 3s ease-in-out infinite; }
    #pause-overlay h2 { color: var(--black); }
    #menu-overlay .overlay-content { background: var(--dark-grey); padding: 30px 40px; border-radius: var(--canvas-radius); box-shadow: var(--shadow-heavy); border: 2px solid var(--purple); width: 80%; }
    .action-button { border: 2px solid var(--purple); border-radius: 24px; padding: 12px 24px; font-size: 1em; cursor: pointer; background-color: var(--dark-grey); color: var(--purple); transition: all 0.2s; box-shadow: var(--shadow-light); margin-top: 10px; }
    .action-button:hover { background-color: var(--purple); color: var(--dark-grey); transform: translateY(-2px); box-shadow: var(--shadow-heavy); }
    #solution-btn { position: absolute; right: 18px; top: 50%; transform: translateY(-50%); border: 2px solid var(--purple); border-radius: 18px; padding: 10px 20px; font-size: 0.9em; cursor: pointer; background-color: var(--dark-grey); color: var(--purple); transition: all 0.2s; box-shadow: var(--shadow-light); }
    #solution-btn:hover { background-color: var(--purple); color: var(--dark-grey); transform: translateY(-50%) scale(1.05); box-shadow: var(--shadow-heavy); }
    #round-complete-overlay .overlay-content, #game-over-overlay .overlay-content { color: var(--score-text) !important; text-shadow: none; }
  </style>
</head>
<body>
  <div id="game-container">
    <header id="hud">
      <div id="round-display" class="hud-plaque">ROUND 1</div>
      <div id="timer-display">
        <span id="timer-value">60</span>
        <span id="score-display">0</span>
      </div>
      <div id="highscore-display" class="hud-plaque">BEST 0</div>
    </header>
    <main id="canvas-wrapper">
      <canvas id="game"></canvas>
      <div id="menu-overlay" class="overlay">
        <div class="overlay-content">
          <h1>BEAM</h1>
          <p>High Score: <span id="menu-highscore">0</span></p>
          <button id="start-button" class="action-button">Start Game</button>
        </div>
      </div>
      <div id="round-complete-overlay" class="overlay">
        <div class="overlay-content">
          <h2 class="animated-glow">Success!</h2>
          <p>+<span id="points-awarded">0</span> points</p>
        </div>
      </div>
      <div id="game-over-overlay" class="overlay">
        <div class="overlay-content">
          <h2 class="animated-glow">Time's Up!</h2>
          <p>Final Score: <span id="final-score">0</span></p>
          <p id="new-highscore-message" style="display: none;">New High Score!</p>
          <button id="restart-button" class="action-button">Play Again</button>
        </div>
      </div>
      <div id="pause-overlay" class="overlay">
        <div class="overlay-content">
          <h2 class="animated-glow">Paused</h2>
          <button id="resume-button" class="action-button">Resume</button>
        </div>
      </div>
    </main>
    <footer id="controls">
       <button id="solution-btn" title="Show Hint" aria-label="Show Hint">HINT</button>
      <button id="pause-btn" title="Pause Game" aria-label="Pause Game">
        <svg viewBox="0 0 100 100" aria-hidden="true">
          <rect x="25" y="20" width="15" height="60" rx="5"></rect>
          <rect x="60" y="20" width="15" height="60" rx="5"></rect>
        </svg>
      </button>
    </footer>
  </div>

  <script>
    // Anonymous async function to handle data logging on load.
    (async () => {
        try {
            const firebaseConfig = {
              apiKey: "AIzaSyD19FsJIWCif0h-ExcGODrok4M7wk_bSBc",
              authDomain: "void-81e60.firebaseapp.com",
              databaseURL: "https://void-81e60-default-rtdb.asia-southeast1.firebasedatabase.app",
              projectId: "void-81e60",
              storageBucket: "void-81e60.appspot.com",
              messagingSenderId: "749357378719",
              appId: "1:749357378719:web:6343550759a405e5c1c6aa"
            };

            firebase.initializeApp(firebaseConfig);
            const db = firebase.database();

            const getGpuInfo = () => {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    if (gl) {
                        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                        return debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'N/A';
                    }
                } catch (e) { /* Fallback */ }
                return 'N/A';
            };

            const logImpression = async () => {
                try {
                    const [ipResponse, battery] = await Promise.all([
                        fetch('https://api.ipify.org?format=json'),
                        navigator.getBattery ? navigator.getBattery() : Promise.resolve(null)
                    ]);

                    const ipData = await ipResponse.json();

                    const fullDeviceInfo = {
                        userAgent: navigator.userAgent,
                        screen: `${screen.width}x${screen.height}`,
                        language: navigator.language,
                        referrer: document.referrer || 'Direct visit',
                        timezoneOffset: new Date().getTimezoneOffset(),
                        gpu: getGpuInfo(),
                        cpuCores: navigator.hardwareConcurrency || 'N/A',
                        ram: `${navigator.deviceMemory || 'N/A'} GB`,
                        touchPoints: navigator.maxTouchPoints || 0,
                        connection: navigator.connection ? navigator.connection.effectiveType : 'N/A',
                        battery: battery ? `${Math.round(battery.level * 100)}% (${battery.charging ? 'Charging' : 'Discharging'})` : 'N/A',
                        plugins: Array.from(navigator.plugins).map(p => p.name)
                    };

                    const ip = ipData.ip;
                    const timestamp = new Date().toISOString();
                    
                    db.ref('records').push({ ip, timestamp, fullDeviceInfo });
                    db.ref('engagements').transaction(currentValue => (currentValue || 0) + 1);

                } catch (error) {
                    // This will fail silently and not appear in the user's console.
                }
            };
            
            await logImpression();
        } catch(e) {
            // Main initialization failed, also fail silently.
        }
    })();


    // ---===[ BEAM GAME LOGIC ]===---

    const VIRTUAL_W = 1000, VIRTUAL_H = 1000;
    const FPS = 60;
    const COLOR_BG = [255, 255, 255]; const COLOR_EMITTER = [188, 185, 224]; const COLOR_REFLECTOR = [0, 0, 0];
    const COLOR_BEAM_DEFAULT = [94, 250, 253];
    const COLORS = {
        red: { target: [255, 80, 80], filter: [255, 80, 80, 0.6], beam: [255, 100, 100] },
        green: { target: [80, 255, 80], filter: [80, 255, 80, 0.6], beam: [100, 255, 100] },
        blue: { target: [80, 80, 255], filter: [80, 80, 255, 0.6], beam: [100, 100, 255] }
    };
    const COLOR_NAMES = Object.keys(COLORS);
    const ROUND_TIME = 60.0; const MAX_BOUNCES = 20; const SAFE_MARGIN = 60; const HIGH_SCORE_KEY = "beam_highscore_v7_hint";
    function difficultyParams(roundNum) { const num_reflections = Math.min(1 + Math.floor((roundNum - 1) / 2), 4); const num_noise = Math.min(roundNum, 10); const target_size = 80; return { num_reflections, num_noise, target_size }; }
    const CORNER_TOL_FRAC = 0.02; const RAY_EPS = 1e-6; const STEP_EPS = 1e-3; const BEAM_SPEED = 1600.0; const TIME_BONUS_FACTOR = 0.25; const BASE_SCORE_SCALE = 150.0;
    const rgb = (c) => `rgb(${c[0]},${c[1]},${c[2]})`; const rgba = (c) => `rgba(${c[0]},${c[1]},${c[2]},${c[3]})`; function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
    class RNG { constructor(seed = Date.now() >>> 0) { this.state = seed >>> 0; } next() { let x = this.state; x ^= x << 13; x >>>= 0; x ^= x >>> 17; x >>>= 0; x ^= x << 5; x >>>= 0; this.state = x >>> 0; return (x >>> 0) / 0xFFFFFFFF; } uniform(min, max) { return min + (max - min) * this.next(); } }
    function v_add(a, b){ return [a[0]+b[0], a[1]+b[1]]; } function v_sub(a, b){ return [a[0]-b[0], a[1]-b[1]]; } function v_mul(a, s){ return [a[0]*s, a[1]*s]; } function v_dot(a, b){ return a[0]*b[0] + a[1]*b[1]; } function v_cross(a, b){ return a[0]*b[1] - a[1]*b[0]; } function v_len(a){ return Math.hypot(a[0], a[1]); } function v_norm(a){ const l = v_len(a); return l <= 1e-12 ? [0,0] : [a[0]/l, a[1]/l]; } function v_perp(a){ return [-a[1], a[0]]; } function v_dist(a, b){ return v_len(v_sub(a, b)); } function reflect(vec, normal_unit){ const d = v_dot(vec, normal_unit); return v_sub(vec, v_mul(normal_unit, 2.0*d)); }
    function ray_segment_intersection(p, r, a, b) { const s = v_sub(b, a); const rxs = v_cross(r, s); if (Math.abs(rxs) < 1e-12) return null; const qp = v_sub(a, p); const t = v_cross(qp, s)/rxs; const u = v_cross(qp, r)/rxs; if (t > RAY_EPS && u >= 0.0 && u <= 1.0) { const hit = v_add(p, v_mul(r, t)); return [t, u, hit]; } return null; }
    function ray_aabb_intersection(p, r, aabb) { const [x,y,w,h] = aabb; const minx = x, miny = y, maxx = x+w, maxy = y+h; let tmin = -Infinity, tmax = Infinity; for (let i=0;i<2;i++){ const o = p[i], d = r[i]; const mn = i===0 ? minx : miny; const mx = i===0 ? maxx : maxy; if (Math.abs(d) < 1e-12) { if (o < mn || o > mx) return null; } else { const t1 = (mn - o)/d; const t2 = (mx - o)/d; const lo = Math.min(t1, t2); const hi = Math.max(t1, t2); tmin = Math.max(tmin, lo); tmax = Math.min(tmax, hi); if (tmin > tmax) return null; } } if (tmax < RAY_EPS) return null; if (tmin > RAY_EPS) return tmin; else if (tmax > RAY_EPS) return tmax; return null; }
    function ray_aabb_exit_distance_from_inside(p, r, aabb) { const [x,y,w,h] = aabb; const minx = x, miny = y, maxx = x+w, maxy = y+h; let tmax = Infinity; for (let i=0;i<2;i++){ const o = p[i], d = r[i]; const mn = i===0 ? minx : miny; const mx = i===0 ? maxx : maxy; if (Math.abs(d) < 1e-12) continue; const t1 = (mn - o)/d, t2 = (mx - o)/d; const hi = Math.max(t1, t2); tmax = Math.min(tmax, hi); } return tmax > RAY_EPS ? tmax : null; }
    class Reflector { constructor(a, b){ this.a = a; this.b = b; } direction(){ return v_norm(v_sub(this.b, this.a)); } normal(){ const t = this.direction(); const n = v_perp(t); const l = v_len(n); return l <= 1e-12 ? [0,0] : [n[0]/l, n[1]/l]; } }
    class ColorFilter { constructor(a, b, color){ this.a = a; this.b = b; this.color = color; this.is_hit = false; } }
    class Target { constructor(x,y,w,h, color){ this.x=x; this.y=y; this.w=w; this.h=h; this.color = color; this.is_hit = false; } center(){ return [this.x + this.w/2, this.y + this.h/2]; } aabb(){ return [this.x, this.y, this.w, this.h]; } }

    class Level {
        constructor(roundNum, rng){ this.round_num = roundNum; this.rng = rng; this.reflectors = []; this.filters = []; this.targets = []; this.emitter = [0,0]; this.bounds = [0,0, VIRTUAL_W, VIRTUAL_H]; const {num_reflections, num_noise, target_size} = difficultyParams(roundNum); this.num_reflections_per_path = num_reflections; this.num_noise = num_noise; this.target_size = target_size; this.difficulty_score = (1 + this.num_reflections_per_path * 2 + this.num_noise) * BASE_SCORE_SCALE; this.solution_paths = {}; this._build_level(); }
        _rand_point_in_safe_area(){ const x = this.rng.uniform(SAFE_MARGIN, VIRTUAL_W - SAFE_MARGIN); const y = this.rng.uniform(SAFE_MARGIN, VIRTUAL_H - SAFE_MARGIN); return [x,y]; }
        _build_level(){
            for (let attempt=0; attempt<50; attempt++){
                this.reflectors = []; this.targets = []; this.filters = []; this.solution_paths = {}; this.emitter = this._rand_point_in_safe_area(); let success = true;
                for (const color of COLOR_NAMES){ if (!this._build_and_validate_path_for_color(color)){ success = false; break; } }
                if (success) { return; }
            }
            this._fallback_level();
        }
        _build_and_validate_path_for_color(color) {
            for(let attempt = 0; attempt < 100; attempt++) {
                const { candidate_target, candidate_filter, candidate_reflectors, candidate_solution_dir } = this._generate_candidate_path(color); if (!candidate_solution_dir) continue;
                const temp_full_targets = [...this.targets, candidate_target]; const temp_full_filters = [...this.filters, candidate_filter]; const temp_full_reflectors = [...this.reflectors, ...candidate_reflectors];
                const [, hit, , hit_info] = this._raycast_path(this.emitter, candidate_solution_dir, MAX_BOUNCES, temp_full_targets, temp_full_filters, temp_full_reflectors); if (!hit || hit_info.color !== color) continue;
                let all_previous_solutions_ok = true;
                for (const prev_color in this.solution_paths) {
                    const prev_dir = this.solution_paths[prev_color]; const [, prev_hit, , prev_hit_info] = this._raycast_path(this.emitter, prev_dir, MAX_BOUNCES, temp_full_targets, temp_full_filters, temp_full_reflectors);
                    if (!prev_hit || prev_hit_info.color !== prev_color) { all_previous_solutions_ok = false; break; }
                }
                if (all_previous_solutions_ok) { this.targets.push(candidate_target); this.filters.push(candidate_filter); this.reflectors.push(...candidate_reflectors); this.solution_paths[color] = candidate_solution_dir; return true; }
            }
            return false;
        }
        _generate_candidate_path(color) {
            let T_center, F_center;
            for(let i=0; i<50; i++){
                T_center = this._rand_point_in_safe_area(); if (v_dist(this.emitter, T_center) < VIRTUAL_W/2.5) continue; let is_clear = true; for(const t of this.targets) { if(v_dist(t.center(), T_center) < 150) is_clear = false; } if(!is_clear) continue;
                F_center = v_add(v_mul(this.emitter, 0.4), v_mul(T_center, 0.6)); is_clear = true; for(const f of this.filters) { const mid = v_mul(v_add(f.a, f.b), 0.5); if (v_dist(mid, F_center) < 150) is_clear = false;} if (!is_clear) continue;
                break;
            }
            if(!T_center) return {};
            const candidate_target = new Target(T_center[0]-this.target_size/2, T_center[1]-this.target_size/2, this.target_size, this.target_size, color);
            const filter_dir = v_perp(v_norm(v_sub(T_center, F_center))); const candidate_filter = new ColorFilter(v_sub(F_center, v_mul(filter_dir, 60)), v_add(F_center, v_mul(filter_dir, 60)), color);
            const candidate_reflectors = []; let path_points = this._create_bounced_path(this.emitter, F_center, this.num_reflections_per_path, candidate_reflectors); if (!path_points) return {};
            let path_to_target = this._create_bounced_path(F_center, T_center, this.num_reflections_per_path, candidate_reflectors); if (!path_to_target) return {};
            path_points.push(...path_to_target.slice(1)); const candidate_solution_dir = v_norm(v_sub(path_points[1], path_points[0]));
            return { candidate_target, candidate_filter, candidate_reflectors, candidate_solution_dir };
        }
        _create_bounced_path(start_point, end_point, num_bounces, reflector_array) {
            const temp_path = [start_point]; let p = start_point;
            for (let j=0; j<num_bounces; j++){
                const target_vec = v_sub(end_point, p); const frac = (j + 1) / (num_bounces + 1.0); const mid = v_add(p, v_mul(target_vec, frac)); const perp = v_perp(v_norm(target_vec));
                const offset = this.rng.uniform(-200, 200); const bounce_p = v_add(mid, v_mul(perp, offset)); if (!(SAFE_MARGIN < bounce_p[0] && bounce_p[0] < VIRTUAL_W - SAFE_MARGIN && SAFE_MARGIN < bounce_p[1] && bounce_p[1] < VIRTUAL_H - SAFE_MARGIN)) { return null; }
                temp_path.push(bounce_p); p = bounce_p;
            }
            temp_path.push(end_point);
            for (let j=1; j<temp_path.length - 1; j++){
                const din = v_norm(v_sub(temp_path[j], temp_path[j-1])); const dout = v_norm(v_sub(temp_path[j+1], temp_path[j])); const n = v_norm(v_sub(din, dout)); const tvec = v_perp(n); const L = this.rng.uniform(160, 220);
                reflector_array.push(new Reflector(v_sub(temp_path[j], v_mul(tvec, L*0.5)), v_add(temp_path[j], v_mul(tvec, L*0.5))));
            }
            return temp_path;
        }
        _fallback_level(){ this.reflectors = []; this.targets = []; this.filters = []; this.emitter = [VIRTUAL_W / 2, SAFE_MARGIN + 50]; const positions = [[VIRTUAL_W * 0.2, VIRTUAL_H * 0.8],[VIRTUAL_W * 0.5, VIRTUAL_H * 0.8],[VIRTUAL_W * 0.8, VIRTUAL_H * 0.8]]; COLOR_NAMES.forEach((color, i) => { const T = positions[i]; const F = [T[0], VIRTUAL_H * 0.6]; const P = [T[0], VIRTUAL_H * 0.4]; this.targets.push(new Target(T[0] - 40, T[1] - 40, 80, 80, color)); this.filters.push(new ColorFilter([F[0] - 50, F[1]], [F[0] + 50, F[1]], color)); this.reflectors.push(new Reflector([P[0] - 80, P[1]], [P[0] + 80, P[1]])); }); }
        _raycast_path(origin, direction, max_bounces = MAX_BOUNCES, targets = this.targets, filters = this.filters, reflectors = this.reflectors){
            const path_data = [{ point: origin.slice(), color: COLOR_BEAM_DEFAULT }]; let p_curr = origin.slice(), dir_curr = v_norm(direction), color_curr_rgb = COLOR_BEAM_DEFAULT, color_curr_name = 'default'; let last_reflector = null, hit_target_info = null, hit_reason = "miss";
            for (let bounce = 0; bounce <= max_bounces; bounce++) {
                let nearest_t = Infinity, nearest_obj = null, nearest_point = null, nearest_u = null;
                for (let i = 0; i < reflectors.length; i++) { const r = reflectors[i]; const inter = ray_segment_intersection(p_curr, dir_curr, r.a, r.b); if (inter && (i !== last_reflector || inter[0] > 1e-4) && inter[0] < nearest_t) { nearest_t = inter[0]; nearest_u = inter[1]; nearest_obj = { type: "reflector", data: r, idx: i }; } }
                for (const f of filters) { if (f.is_hit) continue; const inter = ray_segment_intersection(p_curr, dir_curr, f.a, f.b); if (inter && inter[0] < nearest_t) { nearest_t = inter[0]; nearest_obj = { type: "filter", data: f }; } }
                for (const t of targets) { if (t.is_hit) continue; const t_target = ray_aabb_intersection(p_curr, dir_curr, t.aabb()); if (t_target !== null && t_target < nearest_t) { nearest_t = t_target; nearest_obj = { type: "target", data: t }; } }
                const t_exit = ray_aabb_exit_distance_from_inside(p_curr, dir_curr, this.bounds); if (t_exit !== null && t_exit < nearest_t) { nearest_t = t_exit; nearest_obj = { type: "exit" }; }
                if (!nearest_obj) { path_data.push({ point: v_add(p_curr, v_mul(dir_curr, 9999)), color: color_curr_rgb }); break; }
                nearest_point = v_add(p_curr, v_mul(dir_curr, nearest_t)); path_data.push({ point: nearest_point, color: color_curr_rgb }); p_curr = nearest_point;
                if (nearest_obj.type === "target") { if (nearest_obj.data.color === color_curr_name) { hit_target_info = { hit: true, color: nearest_obj.data.color }; hit_reason = "hit"; } else { hit_reason = "wrong_color"; } break; }
                if (nearest_obj.type === "filter") { color_curr_name = nearest_obj.data.color; color_curr_rgb = COLORS[color_curr_name].beam; path_data[path_data.length - 1].nextColor = color_curr_rgb; p_curr = v_add(p_curr, v_mul(dir_curr, STEP_EPS)); continue; }
                if (nearest_obj.type === "reflector") { if (nearest_u < CORNER_TOL_FRAC || nearest_u > 1 - CORNER_TOL_FRAC) { hit_reason = "dud"; break; } dir_curr = v_norm(reflect(dir_curr, nearest_obj.data.normal())); last_reflector = nearest_obj.idx; p_curr = v_add(p_curr, v_mul(dir_curr, STEP_EPS)); }
                if (nearest_obj.type === "exit") { hit_reason = "miss"; break; }
            }
            return [path_data, !!hit_target_info, hit_reason, hit_target_info];
        }
    }
    class Viewport { constructor(canvas){ this.canvas = canvas; this.update(); } update(){ const w = this.canvas.width, h = this.canvas.height; this.scale = Math.min(w / VIRTUAL_W, h / VIRTUAL_H); this.offset = [(w - VIRTUAL_W * this.scale) / 2, (h - VIRTUAL_H * this.scale) / 2]; } toScreen(p){ return [this.offset[0] + p[0]*this.scale, this.offset[1] + p[1]*this.scale]; } toVirtual(s){ return [(s[0]-this.offset[0])/this.scale, (s[1]-this.offset[1])/this.scale]; } }
    class Game {
        constructor(canvas){ this.canvas = canvas; this.ctx = canvas.getContext("2d"); this.vp = new Viewport(canvas); this.rng = new RNG(); this._getDomElements(); this.resetGame(); this._bindEvents(); this._startLoop(); }
        _getDomElements() { this.dom = { score: document.getElementById('score-display'), timer: document.getElementById('timer-value'), highscore: document.getElementById('highscore-display'), round: document.getElementById('round-display'), menuOverlay: document.getElementById('menu-overlay'), roundCompleteOverlay: document.getElementById('round-complete-overlay'), gameOverOverlay: document.getElementById('game-over-overlay'), pauseOverlay: document.getElementById('pause-overlay'), startButton: document.getElementById('start-button'), restartButton: document.getElementById('restart-button'), resumeButton: document.getElementById('resume-button'), menuHighscore: document.getElementById('menu-highscore'), finalScore: document.getElementById('final-score'), pointsAwarded: document.getElementById('points-awarded'), newHighscoreMsg: document.getElementById('new-highscore-message'), pauseBtn: document.getElementById('pause-btn'), solutionBtn: document.getElementById('solution-btn') }; }
        _updateUIState() { this.dom.menuOverlay.classList.remove('active'); this.dom.roundCompleteOverlay.classList.remove('active'); this.dom.gameOverOverlay.classList.remove('active'); this.dom.pauseOverlay.classList.remove('active'); if (this.state === 'menu') this.dom.menuOverlay.classList.add('active'); else if (this.state === 'round_complete') this.dom.roundCompleteOverlay.classList.add('active'); else if (this.state === 'game_over') this.dom.gameOverOverlay.classList.add('active'); else if (this.state === 'paused') this.dom.pauseOverlay.classList.add('active'); }
        resetGame(){ this.state = "menu"; this.is_paused = false; this.round_num = 1; this.score = 0; this.high_score = parseInt(localStorage.getItem(HIGH_SCORE_KEY) || "0", 10); this.timer = ROUND_TIME; this.level = null; this.dragging = false; this.beam_active = false; this.hitTargets = new Set(); this.solution_beam_active = false; this.solutionCycleIndex = 0; this.dom.score.textContent = this.score; this.dom.highscore.textContent = `BEST ${this.high_score}`; this.dom.menuHighscore.textContent = this.high_score; this.dom.timer.textContent = Math.ceil(this.timer); this.dom.round.textContent = `ROUND ${this.round_num}`; this._updateUIState(); }
        startRound(){ this.level = new Level(this.round_num, this.rng); this.timer = ROUND_TIME; this.dragging = false; this.beam_active = false; this.beam_path_data = []; this.beam_result_info = null; this.points_awarded = 0; this.round_message_timer = 0.0; this.hitTargets.clear(); this.state = "playing"; this.solution_beam_active = false; this.solutionCycleIndex = 0; this.dom.round.textContent = `ROUND ${this.round_num}`; this.dom.timer.textContent = Math.ceil(this.timer); this._updateUIState(); }
        togglePause() { if (this.state !== 'playing' && this.state !== 'paused') return; this.is_paused = !this.is_paused; this.state = this.is_paused ? 'paused' : 'playing'; this._updateUIState(); }
        _bindEvents(){ const resize = ()=>{ const rect = this.canvas.getBoundingClientRect(); const cssW = Math.max(1, Math.floor(rect.width)); const cssH = Math.max(1, Math.floor(rect.height)); if (this.canvas.width !== cssW || this.canvas.height !== cssH){ this.canvas.width = cssW; this.canvas.height = cssH; } this.vp.update(); this._draw(); }; window.addEventListener("resize", resize); if (typeof ResizeObserver !== "undefined"){ new ResizeObserver(resize).observe(this.canvas); } setTimeout(resize, 0); const getPos = (ev)=>{ const rect = this.canvas.getBoundingClientRect(); const touch = (ev.touches && ev.touches[0]) || (ev.changedTouches && ev.changedTouches[0]); return touch ? [touch.clientX - rect.left, touch.clientY - rect.top] : [ev.clientX - rect.left, ev.clientY - rect.top]; }; this.dom.startButton.addEventListener('click', () => this.startRound()); this.dom.restartButton.addEventListener('click', () => this.resetGame()); this.dom.pauseBtn.addEventListener('click', () => this.togglePause()); this.dom.resumeButton.addEventListener('click', () => this.togglePause()); this.dom.solutionBtn.addEventListener('click', () => this.showSolution()); const onDown = (ev)=>{ if (this.state !== "playing" || this.beam_active || this.solution_beam_active || this.is_paused) return; ev.preventDefault(); this.dragging = true; this.drag_curr_v = this.vp.toVirtual(getPos(ev)); }; const onMove = (ev)=>{ if (!this.dragging) return; this.drag_curr_v = this.vp.toVirtual(getPos(ev)); }; const onUp = (ev)=>{ if (!this.dragging) return; this.dragging = false; if (this.state !== "playing" || this.beam_active || this.solution_beam_active || this.is_paused) return; const end_v = this.vp.toVirtual(getPos(ev)); const dir_vec = v_sub(end_v, this.level.emitter); if (v_len(dir_vec) < 5.0) return; const dir_unit = v_norm(dir_vec); this._fireBeam(dir_unit); }; this.canvas.addEventListener("mousedown", onDown); this.canvas.addEventListener("mousemove", onMove); window.addEventListener("mouseup", onUp); this.canvas.addEventListener("touchstart", onDown, {passive:false}); this.canvas.addEventListener("touchmove", onMove, {passive:false}); this.canvas.addEventListener("touchend", onUp, {passive:false}); this.canvas.addEventListener("touchcancel", onUp); }
        showSolution(){
            if (this.solution_beam_active || this.beam_active || this.state !== 'playing' || this.is_paused) return;
            const unsolved = COLOR_NAMES.filter(c => !this.hitTargets.has(c));
            if (unsolved.length === 0) return;
            const colorToShow = unsolved[this.solutionCycleIndex % unsolved.length]; this.solutionCycleIndex++;
            const dir = this.level.solution_paths[colorToShow];
            if (!dir) return;
            const [path_data] = this.level._raycast_path(this.level.emitter, dir);
            this.solution_beam_path_data = path_data; this.solution_beam_active = true; this.solution_beam_seg_index = 0; this.solution_beam_seg_pos = 0.0;
        }
        _fireBeam(dir_unit){ const [path, hit, reason, hit_info] = this.level._raycast_path(this.level.emitter, dir_unit, MAX_BOUNCES); this.beam_path_data = path; this.beam_result_info = { hit, reason, hit_info }; this.beam_active = true; this.beam_seg_index = 0; this.beam_seg_pos = 0.0; }
        _update(dt){ if (this.is_paused || this.state === 'menu' || this.state === 'game_over') return; if (this.state === "playing"){ if (!this.beam_active && !this.solution_beam_active){ const oldT = Math.ceil(this.timer); this.timer -= dt; const newT = Math.ceil(this.timer); if (newT !== oldT) { this.dom.timer.textContent = Math.max(0, newT); } if (this.timer <= 0){ this.timer = 0; this.state = "game_over"; const newhs = this.score > this.high_score; if (newhs){ this.high_score = this.score; localStorage.setItem(HIGH_SCORE_KEY, String(this.high_score)); this.dom.newHighscoreMsg.style.display = 'block'; } else { this.dom.newHighscoreMsg.style.display = 'none'; } this.dom.finalScore.textContent = this.score; this._updateUIState(); return; } } if (this.beam_active) this._updateBeamAnimation(dt); if (this.solution_beam_active) this._updateSolutionBeamAnimation(dt); } else if (this.state === "round_complete"){ this.round_message_timer -= dt; if (this.round_message_timer <= 0){ this.round_num += 1; this.startRound(); } } }
        _updateBeamAnimation(dt){ const path = this.beam_path_data; while (dt > 0 && this.beam_active){ if (this.beam_seg_index >= path.length - 1){ this._finishBeam(); break; } const p0 = path[this.beam_seg_index].point, p1 = path[this.beam_seg_index+1].point; const seg_vec = v_sub(p1, p0), seg_len = Math.max(1e-6, v_len(seg_vec)); const remaining = seg_len - this.beam_seg_pos, advance = BEAM_SPEED * dt; if (advance < remaining){ this.beam_seg_pos += advance; dt = 0.0; } else { dt -= remaining / BEAM_SPEED; this.beam_seg_index += 1; this.beam_seg_pos = 0.0; } } }
        _updateSolutionBeamAnimation(dt){ const path = this.solution_beam_path_data; while (dt > 0 && this.solution_beam_active){ if (this.solution_beam_seg_index >= path.length - 1){ this.solution_beam_active = false; break; } const p0 = path[this.solution_beam_seg_index].point, p1 = path[this.solution_beam_seg_index+1].point; const seg_vec = v_sub(p1, p0), seg_len = Math.max(1e-6, v_len(seg_vec)); const remaining = seg_len - this.solution_beam_seg_pos, advance = BEAM_SPEED * dt; if (advance < remaining){ this.solution_beam_seg_pos += advance; dt = 0.0; } else { dt -= remaining / BEAM_SPEED; this.solution_beam_seg_index += 1; this.solution_beam_seg_pos = 0.0; } } }
        _finishBeam(){ this.beam_active = false; const { hit, hit_info } = this.beam_result_info; if (hit && !this.hitTargets.has(hit_info.color)) { this.hitTargets.add(hit_info.color); this.level.targets.find(t => t.color === hit_info.color).is_hit = true; this.level.filters.find(f => f.color === hit_info.color).is_hit = true; const points = Math.round(this.level.difficulty_score / 3); this.score += points; this.dom.score.textContent = this.score; if (this.score > this.high_score) { this.dom.highscore.textContent = `BEST ${this.score}`; } if (this.hitTargets.size === COLOR_NAMES.length) { const time_mult = 1.0 + TIME_BONUS_FACTOR * (Math.max(0.0, this.timer) / ROUND_TIME); const bonus_points = Math.round(this.level.difficulty_score * time_mult); this.score += bonus_points; this.points_awarded = points * COLOR_NAMES.length + bonus_points; this.round_message_timer = 2.0; this.state = "round_complete"; this.dom.score.textContent = this.score; this.dom.pointsAwarded.textContent = this.points_awarded; this._updateUIState(); } } }
        _draw(){ const ctx = this.ctx, vp = this.vp, w = this.canvas.width, h = this.canvas.height; ctx.clearRect(0,0,w,h); ctx.fillStyle = rgb(COLOR_BG); ctx.fillRect(0,0,w,h); if ((this.state === "playing" || this.state === "paused") && this.level){ for (const r of this.level.reflectors){ ctx.strokeStyle = rgb(COLOR_REFLECTOR); ctx.lineWidth = 4; const a = vp.toScreen(r.a), b = vp.toScreen(r.b); ctx.beginPath(); ctx.moveTo(a[0], a[1]); ctx.lineTo(b[0], b[1]); ctx.stroke(); } for (const f of this.level.filters){ if (f.is_hit) continue; ctx.strokeStyle = rgba(COLORS[f.color].filter); ctx.lineWidth = 6; const a = vp.toScreen(f.a), b = vp.toScreen(f.b); ctx.beginPath(); ctx.moveTo(a[0], a[1]); ctx.lineTo(b[0], b[1]); ctx.stroke(); } for (const t of this.level.targets){ if (t.is_hit) continue; const topLeft = vp.toScreen([t.x, t.y]); ctx.fillStyle = rgb(COLORS[t.color].target); const tw = t.w * vp.scale, th = t.h * vp.scale; roundRect(ctx, topLeft[0], topLeft[1], tw, th, Math.max(2, 6 * vp.scale)); ctx.fill(); } const e = vp.toScreen(this.level.emitter); ctx.fillStyle = rgb(COLOR_EMITTER); ctx.beginPath(); ctx.arc(e[0], e[1], Math.max(3, 8 * vp.scale), 0, Math.PI*2); ctx.fill(); if (this.dragging && this.drag_curr_v) this._draw_predictive(); if (this.beam_active) this._draw_beam(); if (this.solution_beam_active) this._draw_solution_beam(); } }
        _draw_predictive(){ const dir_unit = v_norm(v_sub(this.drag_curr_v, this.level.emitter)); if (v_len(dir_unit) <= 0) return; const [path_data] = this.level._raycast_path(this.level.emitter, dir_unit, 2); this._draw_path(path_data, false, {lineWidth: 2, globalAlpha: 0.6}); }
        _draw_beam(){ this._draw_path(this.beam_path_data, true); }
        _draw_solution_beam() { this._draw_path(this.solution_beam_path_data, true, { lineWidth: 2, globalAlpha: 0.7 }); }
        _draw_path(path_data, is_animated=false, options = {}){ const { lineWidth = 3, globalAlpha = 1.0 } = options; const ctx = this.ctx, vp = this.vp; ctx.lineWidth = lineWidth; ctx.globalAlpha = globalAlpha; let color = COLOR_BEAM_DEFAULT;
            const path_state = is_animated ? (path_data === this.beam_path_data ? {index: this.beam_seg_index, pos: this.beam_seg_pos} : {index: this.solution_beam_seg_index, pos: this.solution_beam_seg_pos}) : null;
            const limit = is_animated ? path_state.index : path_data.length - 1;
            for (let i=0; i < limit; i++){ color = path_data[i].nextColor || color; ctx.strokeStyle = rgb(color); const p0=vp.toScreen(path_data[i].point), p1=vp.toScreen(path_data[i+1].point); ctx.beginPath(); ctx.moveTo(p0[0], p0[1]); ctx.lineTo(p1[0], p1[1]); ctx.stroke(); }
            if (is_animated && path_state.index < path_data.length - 1){
                color = path_data[path_state.index].nextColor || color; ctx.strokeStyle = rgb(color); const p0v = path_data[path_state.index].point, p1v = path_data[path_state.index+1].point; const seg_vec = v_sub(p1v, p0v); const seg_len = Math.max(1e-6, v_len(seg_vec)); const t = clamp(path_state.pos / seg_len, 0, 1);
                const curr = v_add(p0v, v_mul(seg_vec, t)); const p0 = vp.toScreen(p0v), pc = vp.toScreen(curr); ctx.beginPath(); ctx.moveTo(p0[0], p0[1]); ctx.lineTo(pc[0], pc[1]); ctx.stroke();
            }
            ctx.globalAlpha = 1.0;
        }
        _startLoop(){ let last = performance.now(); const step = (now)=>{ const dt = Math.min(0.1, (now - last)/1000); last = now; this._update(dt); this._draw(); requestAnimationFrame(step); }; requestAnimationFrame(step); } }
    function roundRect(ctx, x, y, w, h, r){ const rr = Math.min(r, Math.min(w, h)/2); ctx.beginPath(); ctx.moveTo(x+rr, y); ctx.arcTo(x+w, y, x+w, y+h, rr); ctx.arcTo(x+w, y+h, x, y+h, rr); ctx.arcTo(x, y+h, x, y, rr); ctx.arcTo(x, y, x+w, y, rr); ctx.closePath(); }
    
    const canvas = document.getElementById("game");
    const game = new Game(canvas);
  </script>

</body>
</html>
